# 正则归纳

*   [正则归纳](#%E6%AD%A3%E5%88%99%E5%BD%92%E7%BA%B3)
    *   [前言](#%E5%89%8D%E8%A8%80)
    *   [匹配规则](#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99)
        *   [1\. 直接量字符](#1-%E7%9B%B4%E6%8E%A5%E9%87%8F%E5%AD%97%E7%AC%A6)
        *   [2\. 字符类](#2-%E5%AD%97%E7%AC%A6%E7%B1%BB)
        *   [3\. 重复字符](#3-%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6)
        *   [4\. 选择、分组和引用](#4-%E9%80%89%E6%8B%A9%E5%88%86%E7%BB%84%E5%92%8C%E5%BC%95%E7%94%A8)
        *   [5\. 指定匹配位置](#5-%E6%8C%87%E5%AE%9A%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE)
        *   [6\. 修饰符](#6-%E4%BF%AE%E9%A5%B0%E7%AC%A6)
    *   [String对象中用于模式匹配的方法](#string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%94%A8%E4%BA%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E6%96%B9%E6%B3%95)
    *   [RegExp对象](#regexp%E5%AF%B9%E8%B1%A1)
        *   [属性](#%E5%B1%9E%E6%80%A7)
        *   [方法](#%E6%96%B9%E6%B3%95)
    *   [工具](#%E5%B7%A5%E5%85%B7)
    *   [Reference](#reference)

## 前言

将常用的整理下，方便查看。

## 匹配规则

### 1. 直接量字符

按照字面意义匹配的字符。如字母和数字字符，控制字符等。

### 2. 字符类

将直接量字符单独放进方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符。另外，[^...]匹配不在方括号内的任意字符。

下面的字符均等价于一个字符类：

| 字符 | 匹配 |
| ---- | ---- |
| . | 除换行符和其他Unicode行终止符之外的任意字符 |
| \w | 单词字符，等价于[a-zA-Z0-9_] |
| \W | 非单词字符，等价于[^\w] |
| \s | 任何Unicode空白符，相当于[ \t\r\n\f\v] \(注意括号内第一个字符是空格\)
| \S | 任何非Unicode空白符的字符，相当于[^\s] |
| \d | 任何ASCII数字，等价于[0-9] |
| \D | 除了ASCII数字之外的任何字符，等价于[^\d] |

值得一提的是，与单个的“\b”含义不同，[\b]表示退格直接量。

### 3. 重复字符

用来匹配前一项 (单个字符或(...)) 若干次。

语法如下：

| 字符 | 含义 |
| ---- | ---- |
| {n,m} | 匹配前一项至少n次，但不能超过m次 |
| {n,} | 匹配前一项n次至无限次 |
| {,m} | 匹配前一项0次至m次 |
| {n} | 匹配前一项n次 |
| ? | 匹配前一项0次或者1次 |
| + | 匹配前一项1次或者多次 |
| * | 匹配前一项0次或者多次 |

上述重复字符都是尽可能地多匹配，是贪婪的匹配，要进行非贪婪的匹配，可以在重复字符后加一个“?”，如`/a+?/`匹配一个或多个连续字母a，但它是尽可能少地匹配，对于`aaa`，它只匹配第一个`a`。

值得一提的是，当用非贪婪模式匹配字符匹配失败时，非贪婪模式会最小限度地再匹配一些，以使整个字符串匹配成功，所以`/a+?b/`能匹配`aaab`。

### 4. 选择、分组和引用

总结如下：

| 字符 | 含义 |
| ---- | ---- |
| \| | 选择，匹配的是该符号左边的子表达式或右边的子表达式，一旦左边的子表达式匹配成功则不再匹配右边的子表达式 |
| (...) | 组合，将几个项组合为一个单元，这个单元可以通过“*”，“+”，“?”，“\|”等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用 |
| (?**:**...) | 只组合，把项组合到一个单元，但不记忆与该组相匹配的字符 |
| \n | 和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式 (也有可能是嵌套的)，组索引是从左到右的左括号数，“(?:”形式的分组不编码 |

例如，`/(['"])[^'"]*\1/`匹配位于双单引号或双双引号之内的0个或多个字符。

### 5. 指定匹配位置

指定匹配位置的字符：

| 字符 | 含义 |
| ---- | ---- |
| ^ | 匹配字符串的开头，在多行检索中，匹配每一行的开头 |
| $ | 匹配字符串的结尾，在多行检索中，匹配每一行的结尾 |
| \A | 仅匹配字符串的开头 |
| \Z | 仅匹配字符串的末尾 |
| \b | 匹配一个单词的边界，简言之，就是位于字符\w和\W之间的位置，或位于字符\w和字符串的开头或者结尾之间的位置 (此处注意与[\b]区别) |
| \B | 匹配非单词边界的位置 |
| (?=p) | 零宽正向先行断言，要求之后的字符都与p匹配，才能使整个整个正则表达式匹配成功。不“消费”字符串。 |
| (?!p) | 零宽负向先行断言，要求之后的字符不与p匹配，才能使整个正则表达式匹配成功。不“消费”字符串。 |
| (?<=p) | 零宽正向后发断言，要求之前的字符都与p匹配，才能使整个整个正则表达式匹配成功。不“消费”字符串。 |
| (?<\!p) | 零宽负向后发断言，要求之前的字符不与p匹配，才能使整个正则表达式匹配成功。不“消费”字符串。 |

### 6. 修饰符

用以说明高级匹配模式的规则，放在正则表达式的第二条斜线之后。

JavaScript支持以下修饰符：

| 字符 | 含义 |
| ---- | ---- |
| i | 执行不区分大小写的匹配 |
| g | 执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止 |
| m | 多行匹配模式，此模式下^匹配每行的开头和字符串的开头，$匹配每行的结束和字符串的结束 |
| u | **ES6新增**，开启Unicode匹配模式。开启前，正则表达式基于Unicode字符平面中的0号平面 (*BMP*) 进行匹配，超出这个范围的字符会被当作2个字符处理。增加了这个修饰符后，超出这个范围的字符也会被当作一个字符处理 |
| y | **ES6新增**，开启粘性模式。开启后只会从lastIndex指定的位置开始匹配，**并且不会向后移动来使匹配成功，这一点与g描述符是不同的**，在lastIndex位置匹配成功会更新lastIndex并返回结果，失败则重置lastIndex为0 |

对于u修饰符，有如下栗子：

```js
/^.-clef/ .test( "𝄞-clef" );		// false
/^.-clef/u.test( "𝄞-clef" );		// true
```

对于y修饰符，栗子如下：

```js
var re2 = /foo/y, // <-- notice the `y` sticky flag
	str = "++foo++";

re2.lastIndex; // 0
re2.test( str ); // false -- "foo" not found at `0`
re2.lastIndex; // 0

re2.lastIndex = 2;
re2.test( str ); // true
re2.lastIndex; // 5 -- updated to after previous match

re2.test( str ); // false
re2.lastIndex; // 0 -- reset after previous match failure
```

## String对象中用于模式匹配的方法

| 方法 | 描述 | 实例 |
| ---- | ---- | ---- |
| String.search(regexp) | 参数是正则表达式，返回第一个与之匹配的子串的起始位置，若找不到匹配的子串，则返回-1 | "Javascript".search(/script/i); // 返回4 |
| String.replace(regexp, replacement) | 执行检索和替换操作，第二个参数是要替换成的字符串 | // 这里text指代一段文本 text.replace(/javascript/gi, "JavaScript"); |
| String.match(regexp) | 返回一个由匹配结果组成的数组，若正则表达式设置了修饰符g，则返回的数组包含字符串中的所有匹配结果，非全局检索模式下返回的数组第一个元素为匹配的字符串，余下的元素为圆括号子表达式匹配的文本 | "1 plus 2 equals 3".match(/\d+/g); // 返回 ["1", "2", "3"] |
| String.split(delimiter) | 第一个参数是分割符或者正则表达式，返回由切分的字符串组成的数组 | "1, 2, 3, 4, 5".split(/\s*,\s*/); // 返回 ["1", "2", "3", "4", "5"] |

## RegExp对象

在**ES6**之前，RegExp()构造函数只能写为RegExp(pattern[, attributes])，pattern是正则表达式模式主体文本，attributes是修饰符。在**ES6**中，可以把描述符写到第一个参数中，第一个参数的描述符会被第二个参数的描述符覆盖。

### 属性

| 属性 | 描述 |
| ---- | ---- |
| source | 只读字符串，包含正则表达式的文本 (两“/”之间的文本) |
| global | 只读布尔值，用以说明正则表达式是否带修饰符g |
| ignoreCase | 只读布尔值，用以说明正则表达式是否带修饰符i |
| multiline | 只读布尔值，用以说明正则表达式是否带修饰符m |
| lastIndex | 可读写整数，若匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置 |
| flags | **ES6新增**，只读字符串，包含正则表达式的修饰符 |

### 方法

| 方法 | 描述 | 实例 |
| ---- | ---- | ---- |
| RegExp.exec(string) | 在一个字符串中执行匹配检索，找到就返回一个数组，数组第一个元素为匹配的字符串，余下的元素为圆括号子表达式匹配的文本。没找到匹配则返回null。总返回一个匹配结果。若设置了g修饰符，则每次调用从lastIndex指示的位置开始检索 | /java/.exec('javascript'); // 返回 ["java", index: 0, input: "javascript"] |
| RegExp.test(string) | 对某个字符串进行检索，如果包含正则表达式的一个匹配结果，则返回true，否则返回false。如果设置了g修饰符，则每次调用从lastIndex指示处开始检索 | /java/i.test('JavaScript'); // 返回true |

## 工具

所见即所得的在线正则测试网站：[Refiddle](http://refiddle.com/)

不过多用Sublime Text的底部正则搜索功能才是王道。

有补充再加，就酱。

## Reference

* [正则表达式30分钟入门教程](https://deerchao.net/tutorials/regex/regex.htm)
* [正则表达式之：零宽断言不『消费』](http://fxck.it/post/50558232873)
* [JavaScript权威指南(第6版)](https://book.douban.com/subject/10549733/)
* [《You Don't Know JS》- Regular Expressions](https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20%26%20beyond/ch2.md#regular-expressions)
